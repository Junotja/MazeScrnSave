/*
 *  @file  : MazeScrnSave.cpp
 *  @author: Shilyx
 *  @date  : 2014-06-23 11:47:08.677
 *  @note  : Generated by SlxTemplates
 */

#pragma warning(disable: 4786)
#include <Windows.h>
#include <WindowsX.h>
#include <Shlwapi.h>
#include <CommCtrl.h>
#include "resource.h"
#include <TCHAR.H>
#include <vector>
#include <map>
#include <cstdlib>
#include <cmath>
#include "MazeColor.h"
#include "Maze.h"

#pragma comment(lib, "ComCtl32.lib")
#pragma comment(lib, "Shlwapi.lib")

using namespace std;

static const UINT WM_REFRESH = WM_USER + 112;
static TCHAR g_szClassName[] = TEXT("WindowsScreenSaverClass");
static LPCTSTR g_lpRegPath = TEXT("Software\\Shilyx Studio\\MazeScrnSave\\config");
static BOOL g_bRestartOrder = FALSE;
static BOOL g_bPauseOrder = FALSE;

static struct
{
    COLORREF clBackGround;          // 背景
    COLORREF clWall;                // 墙色
    COLORREF clBadPath;             // 不可用的路径
    COLORREF clVisited;             // 正在使用的路径
    COLORREF clPtStart;             // 开始点
    COLORREF clPtEnd;               // 结束点
    unsigned uCellWidth;            // 格子宽度
    unsigned uCellHeight;           // 格子高度
    int      nGenerateSpeed;        // 生成速度，-9-9
    int      nResolveSpeed;         // 求解速度，-9-9
    BOOL     bReDrawBeforeGenerate; // 生成前擦除上次图案
    BOOL     bFlashPath;            // 求解后闪烁路径
    BOOL     bAllowNonSolution;     // 允许生成无解的迷宫

} g_config;

DWORD RegGetInt(HKEY hRoot, LPCTSTR lpRegPath, LPCTSTR lpValue, DWORD dwDefValue)
{
    DWORD dwResult = dwDefValue;
    DWORD dwDataSize = sizeof(dwResult);
    HKEY hKey = NULL;

    RegOpenKeyEx(hRoot, lpRegPath, 0, KEY_QUERY_VALUE, &hKey);

    if (hKey != NULL)
    {
        RegQueryValueEx(hKey, lpValue, NULL, NULL, (unsigned char *)&dwResult, &dwDataSize);

        RegCloseKey(hKey);
    }

    return dwResult;
}

void LoadConfig()
{
    g_config.clBackGround          = RegGetInt(HKEY_CURRENT_USER, g_lpRegPath, TEXT("clBackGround"         ), GetSysColor(COLOR_BTNFACE));
    g_config.clWall                = RegGetInt(HKEY_CURRENT_USER, g_lpRegPath, TEXT("clWall"               ), RGB(0, 0, 0));
    g_config.clBadPath             = RegGetInt(HKEY_CURRENT_USER, g_lpRegPath, TEXT("clBadPath"            ), RGB(155, 155, 155));
    g_config.clVisited             = RegGetInt(HKEY_CURRENT_USER, g_lpRegPath, TEXT("clVisited"            ), RGB(0, 0, 255));
    g_config.clPtStart             = RegGetInt(HKEY_CURRENT_USER, g_lpRegPath, TEXT("clPtStart"            ), RGB(0, 0, 0));
    g_config.clPtEnd               = RegGetInt(HKEY_CURRENT_USER, g_lpRegPath, TEXT("clPtEnd"              ), RGB(255, 0, 0));
    g_config.uCellWidth            = RegGetInt(HKEY_CURRENT_USER, g_lpRegPath, TEXT("uCellWidth"           ), 10);
    g_config.uCellHeight           = RegGetInt(HKEY_CURRENT_USER, g_lpRegPath, TEXT("uCellHeight"          ), 10);
    g_config.nGenerateSpeed        = RegGetInt(HKEY_CURRENT_USER, g_lpRegPath, TEXT("uGenerateSpeed"       ), 5);
    g_config.nResolveSpeed         = RegGetInt(HKEY_CURRENT_USER, g_lpRegPath, TEXT("uResolveSpeed"        ), 0);
    g_config.bReDrawBeforeGenerate = RegGetInt(HKEY_CURRENT_USER, g_lpRegPath, TEXT("bReDrawBeforeGenerate"), FALSE);
    g_config.bFlashPath            = RegGetInt(HKEY_CURRENT_USER, g_lpRegPath, TEXT("bFlashPath"           ), TRUE);
    g_config.bAllowNonSolution     = RegGetInt(HKEY_CURRENT_USER, g_lpRegPath, TEXT("bAllowNonSolution"    ), FALSE);
}

void SaveConfig()
{
    SHSetValue(HKEY_CURRENT_USER, g_lpRegPath, TEXT("clBackGround"         ), REG_DWORD, &g_config.clBackGround         , sizeof(g_config.clBackGround         ));
    SHSetValue(HKEY_CURRENT_USER, g_lpRegPath, TEXT("clWall"               ), REG_DWORD, &g_config.clWall               , sizeof(g_config.clWall               ));
    SHSetValue(HKEY_CURRENT_USER, g_lpRegPath, TEXT("clBadPath"            ), REG_DWORD, &g_config.clBadPath            , sizeof(g_config.clBadPath            ));
    SHSetValue(HKEY_CURRENT_USER, g_lpRegPath, TEXT("clVisited"            ), REG_DWORD, &g_config.clVisited            , sizeof(g_config.clVisited            ));
    SHSetValue(HKEY_CURRENT_USER, g_lpRegPath, TEXT("clPtStart"            ), REG_DWORD, &g_config.clPtStart            , sizeof(g_config.clPtStart            ));
    SHSetValue(HKEY_CURRENT_USER, g_lpRegPath, TEXT("clPtEnd"              ), REG_DWORD, &g_config.clPtEnd              , sizeof(g_config.clPtEnd              ));
    SHSetValue(HKEY_CURRENT_USER, g_lpRegPath, TEXT("uCellWidth"           ), REG_DWORD, &g_config.uCellWidth           , sizeof(g_config.uCellWidth           ));
    SHSetValue(HKEY_CURRENT_USER, g_lpRegPath, TEXT("uCellHeight"          ), REG_DWORD, &g_config.uCellHeight          , sizeof(g_config.uCellHeight          ));
    SHSetValue(HKEY_CURRENT_USER, g_lpRegPath, TEXT("uGenerateSpeed"       ), REG_DWORD, &g_config.nGenerateSpeed       , sizeof(g_config.nGenerateSpeed       ));
    SHSetValue(HKEY_CURRENT_USER, g_lpRegPath, TEXT("uResolveSpeed"        ), REG_DWORD, &g_config.nResolveSpeed        , sizeof(g_config.nResolveSpeed        ));
    SHSetValue(HKEY_CURRENT_USER, g_lpRegPath, TEXT("bReDrawBeforeGenerate"), REG_DWORD, &g_config.bReDrawBeforeGenerate, sizeof(g_config.bReDrawBeforeGenerate));
    SHSetValue(HKEY_CURRENT_USER, g_lpRegPath, TEXT("bFlashPath"           ), REG_DWORD, &g_config.bFlashPath           , sizeof(g_config.bFlashPath           ));
    SHSetValue(HKEY_CURRENT_USER, g_lpRegPath, TEXT("bAllowNonSolution"    ), REG_DWORD, &g_config.bAllowNonSolution    , sizeof(g_config.bAllowNonSolution    ));
}

void ClearConfig()
{
    SHDeleteKey(HKEY_CURRENT_USER, g_lpRegPath);
}

void SafeDebugMessage(LPCTSTR pFormat, ...)
{
    TCHAR szBuffer[2000];
    va_list pArg;

    va_start(pArg, pFormat);
    wvnsprintf(szBuffer, sizeof(szBuffer) / sizeof(TCHAR), pFormat, pArg);
    va_end(pArg);

    OutputDebugString(szBuffer);
}

DWORD CALLBACK UpdatePictureProc(LPVOID lpParam)
{
    int nDelays[] = {0, 1, 2, 5, 10, 20, 50, 100, 200, 500};
    int nIgnors[] = {0, 1, 2, 5, 10, 20, 50, 100, 200, 500};
    DWORD dwIncrising = 0;
    HWND hWindow = (HWND)lpParam;
    RECT rect;
    int nSize = 10;

    srand(GetTickCount());
    GetWindowRect(hWindow, &rect);

    int nWidth = rect.right - rect.left;
    int nHeight = rect.bottom - rect.top;

    CMaze maze(nWidth, nHeight, g_config.uCellWidth, g_config.uCellHeight, true);

    maze.GetColorManager().SetColor(clBackGround, g_config.clBackGround);
    maze.GetColorManager().SetColor(clWall      , g_config.clWall      );
    maze.GetColorManager().SetColor(clBadPath   , g_config.clBadPath   );
    maze.GetColorManager().SetColor(clVisited   , g_config.clVisited   );
    maze.GetColorManager().SetColor(clPtStart   , g_config.clPtStart   );
    maze.GetColorManager().SetColor(clPtEnd     , g_config.clPtEnd     );
    maze.UpdateColors();
    maze.SetReDrawBeforeGenerate(g_config.bReDrawBeforeGenerate);
    maze.SetAllowNonSolution(g_config.bAllowNonSolution);
    maze.SetFlashPath(g_config.bFlashPath);

    while (IsWindow(hWindow))
    {
        if (g_bPauseOrder)
        {
            Sleep(100);
            continue;
        }

        if (g_bRestartOrder)
        {
            g_bRestartOrder = FALSE;
            maze.Restart();
        }

        maze.Next(TRUE);

        switch (maze.GetState())
        {
        case MS_GENERATING:
            if (g_config.nGenerateSpeed < 0)
            {
                if (-g_config.nGenerateSpeed < RTL_NUMBER_OF(nDelays))
                {
                    Sleep(nDelays[-g_config.nGenerateSpeed]);
                }
            }
            else if (g_config.nGenerateSpeed > 0)
            {
                if (g_config.nGenerateSpeed < RTL_NUMBER_OF(nIgnors))
                {
                    if (dwIncrising++ % nIgnors[g_config.nGenerateSpeed] != 0)
                    {
                        continue;
                    }
                }
            }
            break;

        case MS_RESOLVING:
            if (g_config.nResolveSpeed < 0)
            {
                if (-g_config.nResolveSpeed < RTL_NUMBER_OF(nDelays))
                {
                    Sleep(nDelays[-g_config.nResolveSpeed]);
                }
            }
            else if (g_config.nResolveSpeed > 0)
            {
                if (g_config.nResolveSpeed < RTL_NUMBER_OF(nIgnors))
                {
                    if (dwIncrising++ % nIgnors[g_config.nResolveSpeed] != 0)
                    {
                        continue;
                    }
                }
            }
            break;

        default:
            break;
        }

        SendMessage(hWindow, WM_REFRESH, (WPARAM)maze.GetDc(), 0);
    }

    return 0;
}

LRESULT WINAPI ScreenSaverProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
#define ID_TIMER 1
    static int s_nLastX = 0;
    static int s_nLastY = 0;
    static HDC m_hClientDc = NULL;

    switch (message)
    {
    case WM_CREATE:
        m_hClientDc = GetDC(hWnd);
        CloseHandle(CreateThread(NULL, 0, UpdatePictureProc, (LPVOID)hWnd, 0, NULL));
        break;

    case WM_ERASEBKGND:
        return 0;

    case WM_REFRESH:
        if (wParam != 0)
        {
            RECT rect;

            GetClientRect(hWnd, &rect);
            BitBlt(m_hClientDc, 0, 0, rect.right - rect.left, rect.bottom - rect.top, (HDC)wParam, 0, 0, SRCCOPY);
        }
        break;

    case WM_ACTIVATEAPP:
        if (wParam == FALSE && !IsDebuggerPresent())
        {
            DestroyWindow(hWnd);
        }
        break;

    case WM_MOUSEMOVE:
        if ((s_nLastX == 0 && s_nLastY == 0) || 
            (GET_X_LPARAM(lParam) - s_nLastX) * (GET_X_LPARAM(lParam) - s_nLastX) + (GET_Y_LPARAM(lParam) - s_nLastY) * (GET_Y_LPARAM(lParam) - s_nLastY) < 1000
            )
        {
            s_nLastX = GET_X_LPARAM(lParam);
            s_nLastY = GET_Y_LPARAM(lParam);
        }
        else
        {
            DestroyWindow(hWnd);
        }
        break;

    case WM_KEYDOWN:
        if (wParam == TEXT('R'))
        {
            g_bRestartOrder = TRUE;
            break;
        }
        else if (wParam == TEXT('P'))
        {
            g_bPauseOrder = !g_bPauseOrder;
            break;
        }

    case WM_POWER:
    case WM_POWERBROADCAST:
    case WM_SYSKEYDOWN:
    case WM_RBUTTONDOWN:
    case WM_LBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_CLOSE:
        DestroyWindow(hWnd);
        break;

    case WM_MOUSEWHEEL:
        if (GET_WHEEL_DELTA_WPARAM(wParam) > 0)
        {
            if (g_config.nResolveSpeed < 9)
            {
                g_config.nResolveSpeed += 1;
            }
        }
        else
        {
            if (g_config.nResolveSpeed > -9)
            {
                g_config.nResolveSpeed -= 1;
            }
        }
        break;

    case WM_DESTROY:
        if (m_hClientDc != NULL)
        {
            ReleaseDC(hWnd, m_hClientDc);
            m_hClientDc = NULL;
        }
        PostQuitMessage(0);
        break;

    default:
        break;
    }

    return DefWindowProc(hWnd, message, wParam, lParam);
}

int DoScreenSaver(HWND hParentWindow, HINSTANCE hInstance)
{
    WNDCLASSEX wcex = {sizeof(wcex)};

    wcex.style = CS_OWNDC | CS_DBLCLKS | CS_VREDRAW | CS_HREDRAW;
    wcex.lpfnWndProc = (WNDPROC)ScreenSaverProc;
    wcex.cbClsExtra = 0;
    wcex.cbWndExtra = 0;
    wcex.hInstance = hInstance;
    wcex.hIcon = NULL;
    wcex.hCursor = NULL;
    wcex.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
    wcex.lpszMenuName = NULL;
    wcex.lpszClassName = g_szClassName;

    if (!RegisterClassEx(&wcex))
    {
        return 0;
    }

    RECT rect;
    DWORD dwExStyle, dwStyle;

    if (IsWindow(hParentWindow))
    {
        GetClientRect(hParentWindow, &rect);
        dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_DISABLED;
        dwExStyle = 0;
    }
    else
    {
        rect.left = 0;
        rect.top = 0;
        rect.right = GetSystemMetrics(SM_CXSCREEN);
        rect.bottom = GetSystemMetrics(SM_CYSCREEN);
        dwStyle = WS_POPUP | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN;
        dwExStyle = IsDebuggerPresent() ? 0 : WS_EX_TOPMOST;
        ShowCursor(FALSE);
    }

    HWND hWindow = CreateWindowEx(
        dwExStyle,
        g_szClassName,
        g_szClassName,
        dwStyle,
        rect.left,
        rect.top, rect.right - rect.left,
        rect.bottom - rect.top,
        hParentWindow,
        NULL,
        hInstance,
        NULL
        );

    if (!IsWindow(hWindow))
    {
        return 0;
    }

    MSG msg;

    while (TRUE)
    {
        if (GetMessage(&msg, NULL, 0, 0) <= 0)
        {
            break;
        }

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0;
}

LPDWORD GetDlgItemStore(HWND hwndDlg, int nId)
{
    return (LPDWORD)GetWindowLongPtr(GetDlgItem(hwndDlg, nId), GWLP_USERDATA);
}

HBRUSH GetBrush(COLORREF color)
{
    static map<COLORREF, HBRUSH> s_clBrushs;

    map<COLORREF, HBRUSH>::iterator it = s_clBrushs.find(color);

    if (it != s_clBrushs.end())
    {
        return it->second;
    }
    else
    {
        HBRUSH hBrush = CreateSolidBrush(color);

        s_clBrushs[color] = hBrush;

        return hBrush;
    }
}

void ChangeColor(HWND hwndParent, COLORREF *pColor)
{
    static COLORREF cust_colors[16] =
    {
        0x00ffffff,
        0x00ffffff,
        0x00ffffff,
        0x00ffffff,
        0x00ffffff,
        0x00ffffff,
        0x00ffffff,
        0x00ffffff,
        0x00ffffff,
        0x00ffffff,
        0x00ffffff,
        0x00ffffff,
        0x00ffffff,
        0x00ffffff,
        0x00ffffff,
        0x00ffffff,
    };

    CHOOSECOLOR cc = {sizeof(cc)};
    cc.hwndOwner = hwndParent;
    cc.rgbResult = *pColor;
    cc.Flags = CC_RGBINIT;
    cc.lpCustColors = cust_colors;

    cust_colors[0] = g_config.clBackGround;
    cust_colors[1] = g_config.clWall;
    cust_colors[2] = g_config.clBadPath;
    cust_colors[3] = g_config.clVisited;
    cust_colors[4] = g_config.clPtStart;
    cust_colors[5] = g_config.clPtEnd;

    if (ChooseColor(&cc))
    {
        *pColor = cc.rgbResult;
    }
}

INT_PTR WINAPI ScreenSaverConfigureDialog(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
#define WM_REFRESH (WM_USER + 112)

    switch (message)
    {
    case WM_INITDIALOG:
    {
        HICON hIcon = LoadIcon((HINSTANCE)lParam, MAKEINTRESOURCE(IDI_MAINFRAME));

        SendMessage(hwndDlg, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
        SendMessage(hwndDlg, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);

        // 设定界面内容初始值
        SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_CL_BACKGROUND          ), GWLP_USERDATA, (LONG_PTR)&g_config.clBackGround            );
        SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_CL_WALL                ), GWLP_USERDATA, (LONG_PTR)&g_config.clWall                  );
        SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_CL_BADPATH             ), GWLP_USERDATA, (LONG_PTR)&g_config.clBadPath               );
        SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_CL_VISITED             ), GWLP_USERDATA, (LONG_PTR)&g_config.clVisited               );
        SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_CL_BEGIN               ), GWLP_USERDATA, (LONG_PTR)&g_config.clPtStart               );
        SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_CL_END                 ), GWLP_USERDATA, (LONG_PTR)&g_config.clPtEnd                 );
        SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_SPINCELLWIDTH          ), GWLP_USERDATA, (LONG_PTR)&g_config.uCellWidth              );
        SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_SPINCELLHEIGHT         ), GWLP_USERDATA, (LONG_PTR)&g_config.uCellHeight             );
        SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_SPINGENERATESPEED      ), GWLP_USERDATA, (LONG_PTR)&g_config.nGenerateSpeed          );
        SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_SPINRESOLVESPEED       ), GWLP_USERDATA, (LONG_PTR)&g_config.nResolveSpeed           );
        SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_REDRAWBEFOREGENERATE   ), GWLP_USERDATA, (LONG_PTR)&g_config.bReDrawBeforeGenerate   );
        SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_FLASHPATH              ), GWLP_USERDATA, (LONG_PTR)&g_config.bFlashPath              );
        SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_ALLOWNONSOLUTION       ), GWLP_USERDATA, (LONG_PTR)&g_config.bAllowNonSolution       );

        SendDlgItemMessage(hwndDlg, IDC_SPINCELLWIDTH, UDM_SETRANGE32, 1, 500);
        SendDlgItemMessage(hwndDlg, IDC_SPINCELLHEIGHT, UDM_SETRANGE32, 1, 500);
        SendDlgItemMessage(hwndDlg, IDC_SPINGENERATESPEED, UDM_SETRANGE32, -9, 9);
        SendDlgItemMessage(hwndDlg, IDC_SPINRESOLVESPEED, UDM_SETRANGE32, -9, 9);

        SendDlgItemMessage(hwndDlg, IDC_SPINCELLWIDTH, UDM_SETPOS32, 0, g_config.uCellWidth);
        SendDlgItemMessage(hwndDlg, IDC_SPINCELLHEIGHT, UDM_SETPOS32, 0, g_config.uCellHeight);
        SendDlgItemMessage(hwndDlg, IDC_SPINGENERATESPEED, UDM_SETPOS32, 0, g_config.nGenerateSpeed);
        SendDlgItemMessage(hwndDlg, IDC_SPINRESOLVESPEED, UDM_SETPOS32, 0, g_config.nResolveSpeed);

        // 刷新显示
        SendMessage(hwndDlg, WM_REFRESH, 0, 0);

        break;
    }

    case WM_REFRESH:
        CheckDlgButton(hwndDlg, IDC_REDRAWBEFOREGENERATE, g_config.bReDrawBeforeGenerate);
        CheckDlgButton(hwndDlg, IDC_ALLOWNONSOLUTION, g_config.bAllowNonSolution);
        CheckDlgButton(hwndDlg, IDC_FLASHPATH, g_config.bFlashPath);
        SetDlgItemInt(hwndDlg, IDC_CELLWIDTH, g_config.uCellWidth, FALSE);
        SetDlgItemInt(hwndDlg, IDC_CELLHEIGHT, g_config.uCellHeight, FALSE);
        SetDlgItemInt(hwndDlg, IDC_GENERATESPEED, g_config.nGenerateSpeed, TRUE);
        SetDlgItemInt(hwndDlg, IDC_RESOLVESPEED, g_config.nResolveSpeed, TRUE);
        break;

    case WM_SYSCOMMAND:
        if (SC_CLOSE == wParam)
        {
            SaveConfig();
            EndDialog(hwndDlg, 0);
        }
        break;

    case WM_CTLCOLORSTATIC:
        switch (GetDlgCtrlID((HWND)lParam))
        {
        case IDC_CL_BACKGROUND:
        case IDC_CL_WALL:
        case IDC_CL_BADPATH:
        case IDC_CL_VISITED:
        case IDC_CL_BEGIN:
        case IDC_CL_END:
            {
                HDC hDc = (HDC)wParam;
                int nId = GetDlgCtrlID((HWND)lParam);
                COLORREF color = *GetDlgItemStore(hwndDlg, nId);
                HBRUSH hBrush = GetBrush(color);

                SetBkMode(hDc, TRANSPARENT);
                SetTextColor(hDc, CMaze::GetReverseColor(color));

                return (INT_PTR)hBrush;
            }
            break;

        default:
            break;
        }
        break;

    case WM_NOTIFY:
        if (lParam != 0)
        {
            LPNMHDR lpNmHdr = (LPNMHDR)lParam;

            if (lpNmHdr->code == UDN_DELTAPOS)
            {
                LPNMUPDOWN lpNmUD = (LPNMUPDOWN)lpNmHdr;

                switch (wParam)
                {
                case IDC_SPINCELLWIDTH:
                case IDC_SPINCELLHEIGHT:
                case IDC_SPINGENERATESPEED:
                case IDC_SPINRESOLVESPEED:
                    *GetDlgItemStore(hwndDlg, LOWORD(wParam)) = (DWORD)lpNmUD->iPos;
                    SendMessage(hwndDlg, WM_REFRESH, 0, 0);
                    break;

                default:
                    break;
                }

                OutputDebugString(NULL);
            }
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CL_BACKGROUND:
        case IDC_CL_WALL:
        case IDC_CL_BADPATH:
        case IDC_CL_VISITED:
        case IDC_CL_BEGIN:
        case IDC_CL_END:
            ChangeColor(hwndDlg, GetDlgItemStore(hwndDlg, LOWORD(wParam)));
            SendMessage(hwndDlg, WM_REFRESH, 0, 0);
            InvalidateRect(hwndDlg, NULL, TRUE);
            break;

        case IDC_REDRAWBEFOREGENERATE:
        case IDC_ALLOWNONSOLUTION:
        case IDC_FLASHPATH:
            *GetDlgItemStore(hwndDlg, LOWORD(wParam)) = IsDlgButtonChecked(hwndDlg, LOWORD(wParam));
            SendMessage(hwndDlg, WM_REFRESH, 0, 0);
            break;

        case IDC_DEFAULT:
            if (IDYES == MessageBox(hwndDlg, TEXT("是否要恢复默认配置？"), TEXT("请确认"), MB_ICONQUESTION | MB_YESNOCANCEL | MB_DEFBUTTON3))
            {
                ClearConfig();
                EndDialog(hwndDlg, 0);
            }
            break;

        case IDCANCEL:
            SendMessage(hwndDlg, WM_SYSCOMMAND, MAKELONG(SC_CLOSE, 0), 0);
            break;

        default:
            break;
        }
        break;

    default:
        break;
    }

    return FALSE;
}

BOOL WINAPI RegisterDialogClasses(HANDLE hInst)
{
    return TRUE;
}

int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nShowCmd)
{
    int nArgc = 0;
    LPWSTR *lpArgv = CommandLineToArgvW(GetCommandLineW(), &nArgc);

    if (lpArgv != NULL)
    {
        LoadConfig();

        if (nArgc <= 1 || StrCmpNI(lpArgv[1], L"/c", 2) == 0)
        {
            HWND hParentWindow = NULL;

            if (nArgc > 1 && lstrlenW(lpArgv[1]) > 3)
            {
                hParentWindow = (HWND)StrToIntW(lpArgv[1] + 3);
            }

            DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_DIALOG), hParentWindow, ScreenSaverConfigureDialog, (LPARAM)hInstance);

            return 0;
        }
        else if (nArgc > 1 && lstrcmpi(lpArgv[1], L"/s") == 0)
        {
            return DoScreenSaver(NULL, hInstance);
        }
        else if (nArgc > 2 && lstrcmpi(lpArgv[1], L"/p") == 0)
        {
            HWND hParentWindow = (HWND)StrToIntW(lpArgv[2]);
            
            if (IsWindow(hParentWindow))
            {
                return DoScreenSaver(hParentWindow, hInstance);
            }
        }

        LocalFree(lpArgv);
    }

    MessageBox(NULL, TEXT("错误或不支持的调用方式"), NULL, MB_TOPMOST | MB_ICONERROR);

    return 0;
}

#ifndef _DEBUG
#if _MSC_VER <= 1200
#pragma comment(linker, "/Opt:NoWin98")
#endif
#endif

